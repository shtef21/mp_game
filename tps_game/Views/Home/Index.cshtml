@{
    ViewData["Title"] = "Home Page";
}

<div class="text-center mt-4">
    <h1 class="text-[2rem] font-bold">Welcome to the MP Game</h1>
</div>

<div id="loginForm">
    <form class="bg-white shadow-md rounded px-8 pt-6 pb-8 mb-4">
        <div class="mb-4">
            <label class="block text-gray-700 text-sm font-bold mb-2" for="username_i">
                Username
            </label>
            <input class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" id="username_i" type="text" placeholder="Username">
        </div>
        <div class="flex items-center justify-between">
            <button id="signInButton" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline disabled:opacity-75" type="button" disabled onclick="connect()">
                Connect
            </button>
        </div>
    </form>
</div>

<!-- GAME -->
<canvas id="gameCanvas" class="hidden" tabindex="0" style="margin: 0 auto;">
</canvas>

<div class="ml-[100px]">
    <ul id="ulLog" class="list-none">
        <li>
            1. <strong><pre class="inline">Logs go here</pre></strong>
        </li>
    </ul>
</div>

<script>

    var ctx = gameCanvas.getContext("2d");
    let pid = null; // Player's PID

    function addLog(txt) {
        let log = document.createElement('pre');
        let item = document.createElement('li');

        log.classList.add('inline');
        log.innerText = txt;
        item.innerText = (ulLog.children.length + 1) + '. ';
        item.insertAdjacentHTML('beforeend', '<strong>' + log.outerHTML + '</strong>');

        ulLog.insertAdjacentElement('afterbegin', item);
    }

    // Connect web socket
    function connect() {

        const myUsername = username_i.value;
        var url = 'wss://' + location.host;
        var usernameComponent = '?username=' + encodeURIComponent(myUsername);
        var socket = new WebSocket(url + usernameComponent);

        socket.addEventListener('open', function(event) {
            addLog('Connected to ' + url);
            loginForm.classList.add('hidden');
            gameCanvas.classList.remove('hidden');

            gameCanvas.onkeydown = function (event) {
                if (event.keyCode == 87) {
                    socket.send('W');
                }
                else if (event.keyCode == 65) {
                    socket.send('A');
                }
                else if (event.keyCode == 83) {
                    socket.send('S');
                }
                else if (event.keyCode == 68) {
                    socket.send('D');
                }
            }
        });

        socket.addEventListener('message', function(event) {
            addLog('Message from server: ' + event.data);
            console.log(event.data);
            handleMessage(event.data, myUsername);
        });

        socket.addEventListener('close', function(event) {
            addLog('Connection to ' + url + ' closed.');
            loginForm.classList.remove('hidden');
            gameCanvas.classList.add('hidden');
            gameCanvas.onkeydown = null;
        });
    }

    // Draw a map block
    function drawRectangle(y, x, blockSize, fillColor='black', innerBorder=false) {
        
        // First draw the rectangle
        ctx.fillStyle = fillColor;
        ctx.fillRect(x * blockSize, y * blockSize, blockSize, blockSize);

        // Draw border
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.lineWidth = 1;
        ctx.rect(x * blockSize, y * blockSize, blockSize, blockSize);
        ctx.stroke();

        // Red inner border marks the client from his or her enemies
        if (innerBorder === true) {
            ctx.beginPath();
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.rect(x * blockSize, y * blockSize, blockSize - 1, blockSize - 1);
            ctx.stroke();
        }
    }

    // Clear all blocks from the map
    function clearCanvas() {
        ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
    }

    // Draw text on the map block
    function drawText(y, x, text, textSize, fillColor='black') {
        ctx.font = textSize + 'px Consolas';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = fillColor;
        ctx.fillText(text, x * textSize + textSize / 2, y * textSize + textSize / 2 + Math.floor((textSize * 0.075)));
    }

    // Hex number to decimal (used in hexColorToRgb)
    function hexToDecimal(hexNum) {
        return parseInt(hexNum, 16);
    }

    // Convert hex color to RGBA (used when displaying player's teritory blocks)
    function hexColorToRgb(hexColor, opacity='1.0') {
        let css = '';
        css += 'rgba(';
        css += hexToDecimal(hexColor.substring(1, 3)) + ', ';
        css += hexToDecimal(hexColor.substring(3, 5)) + ', ';
        css += hexToDecimal(hexColor.substring(5, 7)) + ', ';
        css += opacity + ')';
        return css;
    }


    function handleMessage(msg, myUsername) {
        let obj = JSON.parse(msg);

        if (obj.type == 'ID') {
            pid = obj.ID;
        }
        else if (obj.type == 'map') {

            let mapWidth = obj.width;
            let mapHeight = obj.height;
            let blockSize = gameCanvas.height / mapHeight; // Block size in pixels

            let currRow = 0;
            let rows = obj.map.split('\n');

            // Remove previous blocks before drawing new ones
            clearCanvas();
            
            // Iterate map rows
            for (let r of rows) {

                let currCol = 0;
                let cols = r.split(' ');

                // Iterate row blocks
                for (let c of cols) {
                    
                    // Default terrain color
                    let blockColor = 'lightblue';

                    // Try to check if this block has a custom color
                    if (c.includes('-')) {
                        blockColor = c.split('-')[2];
                    }

                    if (c == 'x') {
                        // No man's land
                        drawRectangle(currRow, currCol, blockSize, blockColor);
                    }
                    else if (c.split('-')[0] == 'p') {
                        
                        if (c.split('-')[1] == pid) {
                            // Player's main block
                            drawRectangle(currRow, currCol, blockSize, blockColor, true);
                        }
                        else {
                            // Enemies' main block
                            drawRectangle(currRow, currCol, blockSize, blockColor);
                        }

                        // If this player is onturn, show turn count
                        if (c.split('-')[1] == obj?.turn?.playerID) {
                            drawText(currRow, currCol, obj.turn.movesLeft, blockSize);
                        }
                    }
                    else if (c.split('-')[0] == 't') {
                        
                        // Teritory blocks, drawn with 50% opacity
                        if (c.split('-')[1] == pid) {
                            // Player teritory
                            drawRectangle(currRow, currCol, blockSize, hexColorToRgb(blockColor, 0.5));
                        }
                        else {
                            // Enemy teritory
                            drawRectangle(currRow, currCol, blockSize, hexColorToRgb(blockColor, 0.5));
                        }
                    }
                    currCol++;
                }
                currRow++;
            }
        }
    }

    // Initialize page
    document.addEventListener('DOMContentLoaded', function() {

        // Initialize the input form
        username_i.value = '';
        username_i.addEventListener('keyup', function() {
            if (username_i.value.length > 2) {
                signInButton.disabled = false;
            }
            else {
                signInButton.disabled = true;
            }
        });

        // Setup canvas
        gameCanvas.width = 250;
        gameCanvas.height = 250;

    });

</script>